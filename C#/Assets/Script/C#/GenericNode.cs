using System.Collections.Generic;

namespace Script
{
    public struct Pointer
    {
        private int a;
    }


    public class Test
    {
        private List<Pointer> List = new List<Pointer>();

        public void Test1()
        {
            List.Add(new Pointer());
        }
    }
    
    /// <summary>
    /// 泛型：
    /// </summary>
    public class GenericNode
    {
        private List<int> List;
        private List<Pointer> List2;
        private List<object> List3;

        /*
         *CLR 允许创建泛型引用类型和泛型值类型，还有泛型接口和泛型委托，但不允许创建泛型枚举类型。
         *开放类型和封闭类型：
         * 开放类型:
         * 具有泛型类型参数类型称为开放类型。CLR 禁止构造开放类型的任何实例（例如不能new List<T>）
         * 封闭类型：
         * 代码引用泛型类型时可指定一组泛型类型实参。为所有类型参数都传递了实际但数据类型，类型就成了封闭类型。
         * CLR允许构建封闭类型的实例。
         * 泛型类型和继承：
         * 泛型类型仍是类型，所以能从其他任何类型派生。使用泛型类型并指定类型实参时，实际是在CLR中定义了一个新的类型对象，
         * 新的类型对象从从泛型类型对象派生。
         * 泛型类型的同一性：
         * 看不懂，意思是类型不用写全，因为会有类型推断。
         * 代码爆炸：
         * 使用泛型类型参数的方法在进行JIT编译时，CLR获取方法的IL，用指定的类型实参替代，然后创建恰当的本机代码。
         * 但如果泛型类型很多的话就会生成特别多的本机代码，导致代码爆炸。
         * CLR使用了一个优化的办法：缓存，同类型只有第一次调用会编译一次。
         * 另一个优化办法：认为所有的引用类型实参都完全相同，例如List<string> 和List<stream> 能够代码共享，因为他俩都是引用类型。
         * 因为引用类型存的只是指向堆上的指针，而所有的指针都是以相同的方式操作。
         * 但是值类型必须为值类型生成本机代码，这是因为值类型的大小不固定，即使两个值类型大小一样也不行。
         * 
         * 
         *
         * 
         * List<T> 泛型容器：
         * 关于泛型容器存储值类型是不会拆装箱的问题：
         * 为什么不会拆装箱：
         * 当调用list.Add() 是，不是把值类型转化成了引用类型放到了堆上，
         * 而是把值类型的数据复制了一份，复制到容器中的动态数组中，所以不存在拆装箱，
         * 根据下标拿元素时，也是在栈上新搞了一个值类型类型，然后复制值到这个值类型对象。
         * 所以尽量不要把需要存储在泛型容器中值类型弄得很大，因为会频繁的复制。（CLR Via C# 中推荐16字节）4个int？
         * 
         */
    }
}